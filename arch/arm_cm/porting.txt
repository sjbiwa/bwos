Cortex-M0/M3/M4への実装に関する考察

・BWOSでは、システムコールの処理中に再スケジューリングを行い、処理が完了した後
  リターンする前にディスパッチを行っている。その後条件が成立してREADY状態に
  復帰したらディスパッチを呼び出したところに戻ってきてシステムコールから復帰する
  という流れである。
  この機構はよく用いられる気候ではあるが、Crotex-Mが持つ「PendSVC」との相性が
  よくない。PendSVCはシステムコール内でディスパッチが必要となった時点で設定して
  おき、システムコールから復帰する際に ハンドラモード->スレッドモード に移行する
  ことを利用して割り込みを発生させてディスパッチするのが狙いだと考える。
  このため、Cortex-M用に新たにOSコードを作成することも考えたが、それは止める。
  つまり、「ディスパッチにPendSVCは使わない。」

・Cortex-M向けではシステムコール呼び出しにSVCは使わず直接関数を呼び出す方法を
　採用する。Cortex-MではSVCにも割り込み優先度があるが、PRIMASKを設定すると
  SVC呼び出しがエラーとなりHardFaultに落ちてしまうから。
  これは、PRIMASKを割り込み許可/禁止として使用する場合に、割り込み禁止時に
  システムコールを発行するのが難しくなる。

・Tickタイマについて。Cortex-MのSysTickは32ビットカウンタであり、現在のBWOSで
　採用している64ビットticklessタイマに適用するのが難しい。だが、既存のように
  1ms毎にタイマ割り込みが発生してしまうシステムにはしたくない。

・Cortex-M4Fが搭載しているFPUについては当分は未サポートとする。

-----------------------------------------------------------------------------------

・システムコールはSVCを使わずに直接APIを呼び出す
・ユーザーモード(非特権)は使わない
・タスクはスレッドモードで動作。API処理もスレッドモード。スタックもそのまま
・割り込みハンドラは(当然)ハンドラモード。スタックも専用スタック
・タスク動作中はスタックとしてPSPを使う。割り込みハンドラ動作中はMSPを使う。
  つまり、MSPは１つだけ。PSPはタスクの数だけ。
・割り込み許可/禁止はPRIMASKを使う

□ディスパッチ処理について
　ディスパッチ処理は、APIからの呼び出しと割り込みハンドラ復帰時との２種類がある。
  先の考察から変更であるが、割り込みハンドラ復帰時のディスパッチにはPendSVCを
  使うこととする。
  PendSVCは最低優先度に設定。他の割り込みはそれより高い優先度を設定。
	・割り込みからの復帰は次のようになる
	  1. 割り込み発生
	  2. 割り込みハンドラ実行
	  3. 最優先度タスクが切り替わりディスパッチが必要になったらPendSVCを設定。
	  4. 割り込みハンドラ終了
	  5. ここは当然割り込み許可中なのでPendSVCハンドラ起動
	  6. 割り込み禁止
	  7. ハンドラ内でディスパッチ処理
	  8. 割り込み許可
	  9. EXC_RETURNでタスクに復帰
  (7.)の処理はAPIからの呼び出しと共通化できるがそれ以外は別々になる。
  また、(7.)からアイドルタスクを呼び出す場合も割り込みからかAPIからかで処理が
  異なる。
  割り込みからとAPIからの違いは単純にスレッドモードかハンドラモードかである。
  なので、xPSRを見て判断すればよい。

  PendSVCを使うことにより、割り込み要求の遅延時間を抑えることができる。
