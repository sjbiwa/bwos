★fixmb(固定長メモリブロック) 仕様検討
○外部仕様
・ブロックの取得/解放は１エントリずつ (複数個/連続個はできない)
・I/Fは 一般的な request/trequest/releaseとする

○内部仕様
・sys_mallocでメモリブロック配列をアロケートする
・未使用ブロックの管理
  - リストを使って連結しておく。
    [空きブロック0]->[空きブロック1]->[空きブロック2]という感じ。
  - 初期状態でどうするか？
    初期状態でリストを作成するのはコストがかかる。なので配列管理を
    する。
    具体的には、
     -- 空きの先頭位置を記憶
     -- request時先頭ブロックを割り当て。先頭位置を+1
     -- 先頭位置==要素数になったら、割り当てはリスト側に切り替え。以降はリストから。
     -- 解放はリストに連結。
     ※リスクとして、request時に配列/リストどちらから割り当てるか？を毎回チェックする必要がある。
       関数ポインタにする方法もある。
  - 解放時にそのエントリが本当に割り当てられているのかをチェックする方法
    releaseするエントリが本当に割り当てたエントリか？を調べる必要がある。
    範囲チェックは簡単。問題は空きエントリでないことの確認方法。
    いちいち空きリストを調べるわけにはいかない。
    使用中/空きをビットマップで管理する。

オブジェクトの仕様
typedef struct tagFixmbStruct {
    Link      link;           /* 待ちタスク連結用 */
    void*     mb_area;        /* メモリブロック領域 */
    uint32_t  mb_size;        /* メモリブロックサイズ */
    uint32_t  mb_length;      /* メモリブロック総数 */
    void*     (*alloc_func)();/* メモリブロック割り当て関数(配列/リストモード) */
    uint32_t  mb_array_index; /* メモリブロック割り当て位置(配列モード時) */
    List      list;           /* 空きリスト(単方向リンク) */ -> クラス追加
    uint32_t* use_bitmap;     /* 使用中/空き識別ビットマップ */
} FixmbStruct;
